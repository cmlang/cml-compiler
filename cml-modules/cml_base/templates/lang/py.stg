
import "/lang/common.stg"

// Language

lang ::= [
    "fields": false
]

// Keywords

void() ::= "None"

self() ::= "self"

// Blocks

block(statements) ::= <<
<\n><indent()><statements; anchor>
>>

block_empty() ::= <<
<\n><indent()>pass
>>

block_header_terminator() ::= ":"

// Call

super_constructor_name() ::= "super().__init__"

// Strings

to_string_name() ::= "__str__"

to_string_expr(concept) ::= <<
"%s(<\\>
<if(concept.printableProperties)><\\>
<concept.printableProperties:{p|<getter_call(p)>=%s}; separator=", ">)" % (
<indent()><to_string_expr_params(concept); anchor>
)<\\>
<else><\\>
)" % type(self).__name__<\\>
<endif>
>>

to_string_expr_params(concept) ::= <<
type(self).__name__,
<to_string_fields(concept.printableProperties, ",\n")>
>>

to_string_field(property) ::= <<
self.<getter_call(property)>
>>

// Operations

operation_keyword() ::= "def "

operation_name(name) ::= <<
<name; format="underscore-case">
>>

static_operation_modifier() ::= "@staticmethod<\n>"

operation_header_content(instance, name, params, result_type) ::= <<
<name>(<\\>
<if(instance)>self<endif><\\>
<commaIf2(instance, params)><\\>
<params:var_decl(); separator=", ">)<\\>
<\ >-><\ >'<if(result_type)><result_type><else>None<endif>'
>>

var_decl(object) ::= <<
<if(object.name || object.type)><\\>
<field_name(object)>: '<field_type(object)>'<\\>
<if(object.value)><\\>
<\ >=<\ ><literal_expr(object.value)><\\>
<endif><\\>
<else><\\>
<object><\\>
<endif>
>>

local_var_decl(typed_element) ::= <<
<field_name(typed_element)>
>>

return(expression) ::= <<
return <expression>
>>

// Fields

field_init(named_element) ::= <<
<field_access(named_element)> = <field_name(named_element)>
>>

field_name(named_element) ::= <<
<named_element.name; format="underscore-case">
>>

field_access(named_element) ::= <<
self.__<field_name(named_element)>
>>

field_type_optional(type) ::= <<
<type_name(type)>
>>

field_type_sequence(type) ::= <<
List[<type_name(type)>]
>>

field_decl(typed_element) ::= ""

// Getters

getter_name(property) ::= <<
<property.name; format="underscore-case">
>>

interface_getter_annotations(property) ::= <<
@abstractproperty<\n>
>>

class_getter_annotations(property) ::= <<
@property<\n>
>>

getter_type_required(type) ::= <<
<type_name(type)>
>>

getter_type_optional(type) ::= <<
<type_name(type)>
>>

getter_type_sequence(type) ::= <<
List[<type_name(type)>]
>>

getter_field_value_required(property) ::= <<
<field_access(property)>
>>

getter_field_value_optional(property) ::= <<
<field_access(property)>
>>

getter_field_value_sequence(property) ::= <<
<field_access(property)>
>>

getter_call(property) ::= <<
<property.name; format="underscore-case">
>>

// Structure

structure_preamble() ::= "<\n>"

// Interfaces

interface_keyword() ::= "class "

interface_ancestor_header(ancestors, ancestor_list) ::= <<
<\ >(ABC<if(ancestors)>, <ancestor_list><endif>)
>>

interface_operation_body() ::= <<
<block_empty()>
>>

interface_secondary_create_method() ::= ""

// Classes

class_keyword() ::= "class "

class_type_name(name) ::= <<
<name; format="pascal-case">
>>

constructor_name(class_name) ::= "__init__"

class_secondary_constructor(non_init_properties, super_properties) ::= ""

class_static_initializer(concept) ::= ""

// Ancestors

ancestor_list(abstract, ancestors, interfaces) ::= <<
<if(abstract || ancestors || interfaces)>(<endif><\\>
<if(ancestors)><\\>
<ancestors:type_name();separator=", "><\\>
<if(interfaces)>, <endif><\\>
<endif><\\>
<if(interfaces)><interfaces:type_name();separator=", "><endif><\\>
<if(abstract)><if(ancestors || interfaces)>, <endif>ABC<endif><\\>
<if(abstract || ancestors || interfaces)>)<endif>
>>

// Associations

association_singleton(association) ::= <<
_singleton = None
>>

association_new(association) ::= <<
def __new__(cls) -> '<association_name(association)>':
<indent()>if cls._singleton is None:
<indent()><indent()>cls._singleton = super(<association_name(association)>, cls).__new__(cls)
<indent()>return cls._singleton
>>

association_name(association) ::= <<
_<type_name(association)>
>>

association_init(association) ::= ""

association_field_decl(association_ends) ::= ""

association_constructor(association) ::= <<
<instance_operation(
    name=constructor_name(type_name(association)),
    params=[],
    result_type=[],
    statements=association_constructor_statements(association)
)>
>>

association_constructor_statements(association) ::= <<
<association.associationEnds:association_field_init(); separator="\n">
>>

association_field_init(association_end) ::= <<
<field_access(association_end.property)> = {} # type: Dict[<field_type(association_end.concept)>, <field_type(association_end.property)>]
>>

association_link_statement_seq(association_end) ::= <<
if <association_link_source(association_end)> in <association_link_field(association_end)>:
<indent()><association_link_seq(association_end)> = <association_link_field(association_end)>[<association_link_source(association_end)>]
else:
<indent()><association_link_seq(association_end)> = [<association_link_target(association_end)>]
if not (<association_link_target(association_end)> in <association_link_seq(association_end)>):
<indent()><association_link_seq(association_end)>.append(<association_link_target(association_end)>)
<association_link_field(association_end)>[<association_link_source(association_end)>] = <association_link_seq(association_end)>
>>

association_link_statement_non_seq(association_end) ::= <<
<association_link_field(association_end)>[<association_link_source(association_end)>] = <association_link_target(association_end)>
>>

association_link_seq_suffix() ::= "_list"

association_getter_name(property) ::= <<
<property.name; format="underscore-case">_of
>>

association_getter_statements_non_seq(association_end) ::= <<
if <association_link_source(association_end)> in <association_link_field(association_end)>:
<indent()>return <association_link_field(association_end)>[<association_link_source(association_end)>]
else:
<indent()>return None
>>

association_getter_statements_seq(association_end) ::= <<
if <association_link_source(association_end)> in <association_link_field(association_end)>:
<indent()><association_link_seq(association_end)> = <association_link_field(association_end)>[<association_link_source(association_end)>]
else:
<indent()><association_link_seq(association_end)> = []
return list(<association_link_seq(association_end)>)
>>

class_association_field(association) ::= <<
_<field_name(association)> = <association_name(association)>()
>>

class_association_setter(association) ::= ""

association_one_to_many_link_method_statements(association) ::= <<
for <field_name(association.manyProperty.type)> in <field_name(association.manyProperty)>: self.link(<field_name(association.oneProperty)>, <field_name(association.manyProperty.type)>)
>>

association_link_call_seq(property) ::= <<
self._<field_name(property.association)>.link_many(self, <field_name(property)>)
>>

association_link_call_non_seq(property) ::= <<
self._<field_name(property.association)>.link(<field_name(property)>, self)
>>

association_class_getter_expr(property) ::= <<
self._<field_name(property.association)>.<field_name(property)>_of(self)
>>

// Type

primitive_type_boolean() ::= "bool"
primitive_type_integer() ::= "int"
primitive_type_decimal() ::= "Decimal"
primitive_type_string() ::= "str"
primitive_type_regex() ::= "Pattern"
primitive_type_byte() ::= "int"
primitive_type_short() ::= "int"
primitive_type_long() ::= "long"
primitive_type_float() ::= "float"
primitive_type_double() ::= "float"
primitive_type_char() ::= "int"

type_hint_name(name) ::=<<
'<class_type_name(name)>'
>>

// Literal

literal_expr_string(text) ::= <<
"<text>"
>>

literal_expr_integer(text) ::= <<
<text>
>>

literal_expr_long(text) ::= <<
<text>
>>

literal_expr_short(text) ::= <<
<text>
>>

literal_expr_byte(text) ::= <<
<text>
>>

literal_expr_decimal(text) ::= <<
Decimal("<text>")
>>

literal_expr_float(text) ::= <<
<text>
>>

literal_expr_double(text) ::= <<
<text>
>>

// Constants

null_value() ::= "None"

integral_zero() ::= "0"

float_zero() ::= "0"

// Operations

operation_add(left, right) ::= "<left> + <right>"
operation_sub(left, right) ::= "<left> - <right>"
operation_mul(left, right) ::= "<left> * <right>"
operation_div(left, right) ::= "<left> / <right>"
operation_mod(left, right) ::= "<left> % <right>"
operation_exp(left, right) ::= "<left> ** <right>"

operation_eq(left, right) ::= "<left> == <right>"
operation_ineq(left, right) ::= "<left> != <right>"
operation_gt(left, right) ::= "<left> > <right>"
operation_gte(left, right) ::= "<left> >= <right>"
operation_lt(left, right) ::= "<left> \< <right>"
operation_lte(left, right) ::= "<left> \<= <right>"

operation_and(left, right) ::= "<left> and <right>"
operation_or(left, right) ::= "<left> or <right>"
operation_not(expr) ::= "not <expr>"

// Paths

path_start(path) ::= <<
<if(path.type.sequence)>list(<\n><indent()><endif>
>>

path_expr(path) ::= <<
<if(path.base)><\\>
<path_base_call(path)><\\>
<else><\\>
<path_getter_call(path)><\\>
<endif>
>>

path_getter_call(path) ::= <<
self.<path_property(path)>
>>

path_base_call(path) ::= <<
<if(path.base.type.sequence)><\\>
<path_map_call(path); anchor><\\>
<else><\\>
<path_expr(path.base)>.<path_property(path)><\\>
<endif>
>>

path_map_call(path) ::= <<
map(
<indent()>lambda <field_name(path.base.type)>: <field_name(path.base.type)>.<path_property(path)>,
<indent()><path_expr(path.base)>
)
>>

path_property(path) ::= <<
<path.name; format="underscore-case">
>>

path_end(path) ::= <<
<if(path.type.sequence)><\n>)<endif>
>>

