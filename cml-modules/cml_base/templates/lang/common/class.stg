
import "/lang/common/generic.stg"
import "/lang/common/getter.stg"
import "/lang/common/to_string.stg"
import "/lang/common/interface.stg"
import "/lang/common/association.stg"

class(concept) ::= <<
<class7(
    concept=concept,
    class_name_suffix="",
    abstract=concept.abstract,
    ancestors=concept.directAncestors,
    interfaces=[],
    field_ancestors=[],
    delegated_properties=[],
    super_properties=concept.superProperties,
    inherited_properties=concept.redefinedInheritedConcreteProperties
)>
>>

class2(concept, class_name_suffix) ::= <<
<class7(
    concept=concept,
    class_name_suffix=class_name_suffix,
    abstract=false,
    ancestors=[],
    interfaces=[concept],
    field_ancestors=concept.allAncestors,
    delegated_properties=concept.delegatedProperties,
    super_properties=[],
    inherited_properties=[]
)>
>>

class7(
    concept, class_name_suffix,
    abstract,
    ancestors, interfaces,
    field_ancestors,
    delegated_properties, super_properties, inherited_properties
) ::= <<
<class_abstract()><\\>
<structure(
    keyword="class",
    header=class_header(),
    base_list=true,
    sections = [
        class_association_fields(concept),
        class_fields(concept.slotProperties),
        class_secondary_constructor(concept.nonInitProperties, super_properties),
        class_primary_constructor(inherited_properties, super_properties, field_ancestors),
        class_getters(),
        class_to_string(),
        class_association_setters(concept),
        class_static_initializer(concept)
    ]
)>
>>

class_abstract() ::= <<
<if(abstract)><abstract_keyword()><endif>
>>

class_header() ::= <<
<class_name()><ancestor_list(abstract, ancestors, interfaces)>
>>

class_name() ::= <<
<type_name(concept)><class_name_suffix>
>>

class_fields(properties) ::= <<
<ancestor_fields(field_ancestors)><\\>
<emptyLineIf2(field_ancestors, properties)><\\>
<property_fields(properties)>
>>

class_getters() ::= <<
<line_list([
    field_getters(concept.slotProperties),
    association_class_getters(concept.associationProperties),
    derived_getters(concept.derivedProperties),
    delegated_getters(delegated_properties)
])>
>>

ancestor_fields(ancestors) ::= <<
<ancestors:field_decl();separator="\n">
>>

property_fields(properties) ::= <<
<properties:field_decl();separator="\n">
>>

field_getters(properties) ::= <<
<properties:field_getter();separator="\n\n">
>>

derived_getters(properties) ::= <<
<properties:derived_getter();separator="\n\n">
>>

delegated_getters(properties) ::= <<
<properties:delegate_getter();separator="\n\n">
>>

class_primary_constructor(inherited_properties, super_properties, ancestors) ::= <<
<if(ancestors || concept.nonDerivedProperties)><\\>
<modifier("public")><\\>
<class_constructor([ancestors, concept.nonDerivedProperties, super_properties], class_primary_constructor_statements())><\\>
<endif>
>>

class_primary_constructor_statements() ::= <<
<super_constructor(inherited_properties)><\\>
<if(super_properties)><\\>
<concept.nonDerivedProperties:field_init();separator="\n"><\\>
<else><\\>
<[ancestors, concept.slotProperties]:field_init();separator="\n"><\\>
<association_link_calls(concept)><\\>
<endif>
>>

super_constructor(inherited_properties) ::= <<
<if(inherited_properties)><\\>
<super_constructor_call(inherited_properties)>
<endif>
>>

class_secondary_constructor(non_init_properties, super_properties) ::= <<
<if(!interfaces && concept.initProperties)><\\>
<modifier("public")><\\>
<class_constructor(non_init_properties, class_secondary_constructor_statements(concept, super_properties))><\\>
<endif>
>>

class_secondary_constructor_statements(concept, super_properties) ::= <<
<this_constructor_call([concept.nonDerivedProperties, super_properties])>
>>

class_to_string() ::= <<
<to_string(concept)>
>>

class_constructor(params, statements) ::= <<
<instance_operation(
    name=constructor_name(class_name()),
    params=params,
    result_type=[],
    statements=statements
)>
>>

field_getter(property) ::= <<
<class_getter_annotations(property)><\\>
<modifier("public")><\\>
<instance_operation(
    name=getter_name(property),
    params=[],
    result_type=getter_type(property.type),
    statements=return(getter_field_value(property))
)>
>>

derived_getter(property) ::= <<
<if(property.value)><\\>
<derived_concrete_getter(property, expression(property.value))><\\>
<elseif(abstract)><\\>
<derived_abstract_getter(property)><\\>
<else><\\>
<derived_concrete_getter(property, field_or_default_value(property))><\\>
<endif>
>>

derived_concrete_getter(property, expression) ::= <<
<class_getter_annotations(property)><\\>
<modifier("public")><\\>
<instance_operation(
    name=getter_name(property),
    params=[],
    result_type=getter_type(property.type),
    statements=return(expression)
)>
>>

derived_abstract_getter(property) ::= <<
<modifier("public")><\\>
<abstract_keyword()><\\>
<interface_getter(property)>
>>

delegate_getter(property) ::= <<
<class_getter_annotations(property)><\\>
<modifier("public")><\\>
<instance_operation(
    name={<getter_name(property)>},
    params=[],
    result_type=getter_type(property.type),
    statements=return({<field_access(property.parentScope)>.<getter_call(property)>})
)>
>>

class_association_fields(concept) ::= <<
<concept.associations:class_association_field();separator="\n">
>>

class_association_field(association) ::= <<
<concept.associations:class_association_field();separator="\n\n">
>>

class_association_setters(concept) ::= <<
<concept.associations:class_association_setter();separator="\n\n">
>>

class_association_setter(association) ::= <<
<static_operation(
    name=association_setter_name(association),
    params=[association_setter_param(association)],
    result_type=void(),
    statements=association_setter_statements(association)
)>
>>

class_static_initializer(concept) ::= <<
<if(concept.associations)><\\>
<static_initializer(class_static_initializer_statements(concept))><\\>
<endif>
>>

class_static_initializer_statements(concept) ::= <<
<concept.associations:association_static_initializer_statement(concept);separator="\n">
>>