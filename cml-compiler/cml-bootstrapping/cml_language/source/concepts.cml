
@abstraction CONCEPT: NAMED_ELEMENT, PROPERTY_LIST
{
    abstraction: BOOLEAN;

    /derived_properties = properties | select: derived;
    /slot_properties = properties | select: slot;

/*

    /nonDerivedProperties = properties
        | select: not derived
        | sort: p1, p2 ->
            if present(p1) and empty(p2) then +1
            else if empty(p1) and present(p2) then -1
            else 0;
*/

    generalizations: INHERITANCE*;
    specializations: INHERITANCE*;

    /ancestors = generalizations.ancestor;
    /descendants = specializations.descendant;

    /all_properties: PROPERTY*;

    /inherited_properties = distinct(ancestors.all_properties);

/*
    /associations = model.associations | select: (association_ends | exists: concept == self);

    /association_properties = properties | select: present(association);

    /init_properties = all_properties | select: init;
    /non_init_properties = all_properties | select: non_init;
    /printable_properties = all_properties | select: printable;

    /all_properties = concat(properties, non_redefined_properties);
    /non_redefined_properties = for p1 in inherited_properties, p2 in properties
                                    | reject: p1.name == p2.name
                                    | collect: p1
                                    | distinct;
    /super_properties = non_redefined_properties | select: not derived;

    /dependencies = distinct(concat(inherited_dependencies, property_dependencies));
    /property_dependencies = distinct(concat(
                                transitive_property_concepts | collect: inherited_dependencies,
                                transitive_property_concepts | collect: name));
    /inherited_dependencies = all_ancestors | select: name | distinct;

    /transitive_property_concepts = self | recurse_depth: property_concepts;
    /property_concepts = property_types | reject: primitive | yield: concept | distinct;
    /property_types = all_properties | yield: type;

    /all_ancestors = self | recurse_depth: ancestors | distinct;

    /redefined_ancestors: CONCEPT_REDEF*;
    /redefined_inherited_concrete_properties: PROPERTY*;
*/

}

@concept INHERITANCE
{
    ancestor: CONCEPT;
    descendant: CONCEPT;
}

@association GENERALIZATION
{
    INHERITANCE.descendant;
    CONCEPT.generalizations;
}

@association SPECIALIZATION
{
    INHERITANCE.ancestor;
    CONCEPT.specializations;
}

@concept CONCEPT_REDEF
{
    concept: CONCEPT;
    property_redefs: PROPERTY_REDEF*;
}

@concept PROPERTY_REDEF
{
    prop: PROPERTY; // shortened name because Python gets confused with a property called "property".
    redefined: BOOLEAN;
}
