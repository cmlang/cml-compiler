
@abstraction EXPRESSION: SCOPE
{
  /kind: string;
  /type: TYPE;

  /matching_result_type = type;
  /numeric = type.numeric;
  /binary_floating_point = type.binary_floating_point;

  /operands = members as? EXPRESSION*;
}

@concept LITERAL: EXPRESSION
{
  text: string;
  type: TYPE;

  /kind = "literal";
  /diagnostic_id = text;
}

@abstraction INFIX: EXPRESSION
{
  operator: string;

  /operation: string?;

  /left = first(operands) as! EXPRESSION;
  /right = last(operands) as! EXPRESSION;

  /diagnostic_id = left.diagnostic_id & " " & operator & " " & right.diagnostic_id;
}

@concept ARITHMETIC: INFIX
{
  /kind = "arithmetic";

  /operation =
    if operator == "+" then "add" as! string?
    else if operator == "-" then "sub" as! string?
    else if operator == "*" then "mul" as! string?
    else if operator == "/" then "div" as! string?
    else if operator == "%" then "mod" as! string?
    else if operator == "^" then "exp" as! string? // necessary until conditionals are fixed to support "none"
    else none;

  /numeric = left.numeric and right.numeric;
  /binary_floating_point = left.binary_floating_point and right.binary_floating_point;
  /arithmetic = numeric or binary_floating_point;

  /type = if arithmetic and subtype(left.type.name, right.type.name) then right.type
          else if arithmetic and subtype(right.type.name, left.type.name) then left.type
          else UNDEFINED_TYPE("Incompatible operand(s) for operator '" & operator & "':\n" &
                              "- left operand is '" & left.diagnostic_id & ": " & left.type.diagnostic_id & "'\n" &
                              "- right operand is '" & right.diagnostic_id & ": " & right.type.diagnostic_id & "'");
}