
@abstraction EXPRESSION: SCOPE
{
  /kind: string;
  /type: TYPE;

  /operands = members as? EXPRESSION*;

  /matching_result_type = type;

  /boolean = type.boolean;
  /numeric = type.numeric;
  /float = type.float;
  /arithmetic = numeric or float;
}

@concept LITERAL: EXPRESSION
{
  text: string;
  type: TYPE;

  /kind = "literal";
  /diagnostic_id = text;
}

@abstraction INFIX: EXPRESSION
{
  operator: string;

  /operation: string?;

  /left = first(operands) as! EXPRESSION;
  /right = last(operands) as! EXPRESSION;

  /boolean = left.boolean and right.boolean;
  /numeric = left.numeric and right.numeric;
  /float = left.float and right.float;

  /diagnostic_id = left.diagnostic_id & " " & operator & " " & right.diagnostic_id;

  /undefined_type = UNDEFINED_TYPE("Incompatible operand(s) for operator '" & operator & "':\n" &
                                   "- left operand is '" & left.diagnostic_id & ": " & left.type.diagnostic_id & "'\n" &
                                   "- right operand is '" & right.diagnostic_id & ": " & right.type.diagnostic_id & "'");

  /type =
    if left.type.undefined then left.type
    else if right.type.undefined then right.type
    else inferred_type;

  /inferred_type: TYPE;
}

@concept ARITHMETIC: INFIX
{
  /kind = "arithmetic";

  /operation =
    if operator == "+" then "add" as! string?
    else if operator == "-" then "sub" as! string?
    else if operator == "*" then "mul" as! string?
    else if operator == "/" then "div" as! string?
    else if operator == "%" then "mod" as! string?
    else if operator == "^" then "exp" as! string? // type-casting necessary until conditionals are fixed to support "none"
    else none;

  /inferred_type =
    if arithmetic and subtype(left.type.name, right.type.name) then right.type
    else if arithmetic and subtype(right.type.name, left.type.name) then left.type
    else undefined_type;
}

@concept LOGICAL: INFIX
{
  /kind = "logical";
  /operation = operator as? string?;

  /inferred_type =
    if boolean then VALUE_TYPE("", primitive_type_name("boolean")) else undefined_type;
}