
template function exists<T>(seq: T*, expr: (T) -> Boolean) -> Boolean;
template function select<T>(seq: T*, expr: (T) -> Boolean) -> T*;
template function reject<T>(seq: T*, expr: (T) -> Boolean) -> T*;

template function yield<T>(seq: T*, expr: (T) -> R*) -> R*;

//macro recurse(seq: T*, seq/expr: T*): T*;

//macro reduce(from/seq: T*, seq/expr: S, from_i: R): S;

//macro distinct(seq: T*): T*;

concept Expressions
{
    top_items: Item*;
    class: Class;
    children: Class*;
    top_orders: Order*;

    path_ancestors = class.ancestors;

    exists_invocation = exists(top_items, { name == "this" });
    select_invocation = select(top_items, { name == "this" });
    reject_invocation = reject(top_items) { name == "this" }; // trailing lambdas

//    yield_invocation = yield(top_orders, items);
//    yield_invocation_distinct = distinct(yield(top_orders, items.product));

//    recurse_ancestors = recurse(class, ancestors);
//    recurse_distinct = distinct(recurse(class, ancestors));
//    recurse_children = select(recurse(children, children), ranking > 10); // equivalent to: self | recurse children | ...

//    reduce_invocation = reduce(top_orders, s + total, s = 0);

}

concept Order
{
    customer: Customer;
    items: Item*;
    total: Decimal;
}

concept Item
{
    name: String;
    product: Product;
}

concept Customer
{
    name: String;
}

concept Product;

concept Class
{
    ancestors: Class*;
    children: Class*;
    ranking: Integer;
}

